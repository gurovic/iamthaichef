"""
Скрипт для конвертации PostgreSQL дампа в SQLite
"""
import re
import sqlite3
import os
from pathlib import Path

def convert_postgres_to_sqlite(postgres_dump_path, sqlite_db_path):
    """
    Конвертирует дамп PostgreSQL в SQLite базу данных
    """
    print(f"Конвертация дампа {postgres_dump_path} в SQLite базу {sqlite_db_path}")
    
    # Чтение дампа PostgreSQL
    with open(postgres_dump_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Замена PostgreSQL-специфичных элементов на SQLite-совместимые
    # Удаление команд SET
    content = re.sub(r'SET [^;]*;', '', content)
    
    # Удаление команд SELECT pg_catalog.set_config
    content = re.sub(r"SELECT pg_catalog\.set_config\([^)]*\);", '', content)
    
    # Замена типов данных
    content = content.replace('timestamp with time zone', 'TEXT')
    content = content.replace('timestamp without time zone', 'TEXT')
    content = content.replace('date', 'TEXT')
    content = content.replace('boolean', 'INTEGER')
    content = content.replace('bigint', 'INTEGER')
    content = content.replace('integer', 'INTEGER')
    content = content.replace('character varying', 'TEXT')
    content = content.replace('double precision', 'REAL')
    content = content.replace('numeric', 'REAL')
    content = content.replace('bytea', 'BLOB')
    
    # Удаление OID и других PostgreSQL-специфичных элементов
    content = re.sub(r'WITH \(oids = [^\)]*\)', '', content)
    
    # Удаление ограничений CHECK
    content = re.sub(r'CONSTRAINT [^ ]+ CHECK \([^)]+\)[^,)]*', '', content)
    content = re.sub(r',\s*,', ',', content)  # исправление двойных запятых
    
    # Удаление последовательностей (GENERATED BY DEFAULT AS IDENTITY)
    content = re.sub(r'ADD GENERATED BY DEFAULT AS IDENTITY \([^)]+\)', '', content)
    
    # Замена AUTO_INCREMENT для первичных ключей
    content = re.sub(r'id integer NOT NULL,\s*CONSTRAINT', 'id INTEGER PRIMARY KEY AUTOINCREMENT,\n    CONSTRAINT', content)
    content = re.sub(r'id bigint NOT NULL,\s*CONSTRAINT', 'id INTEGER PRIMARY KEY AUTOINCREMENT,\n    CONSTRAINT', content)
    
    # Удаление владельцев таблиц
    content = re.sub(r'ALTER TABLE [^;]*OWNER TO postgres;', '', content)
    
    # Удаление GRANT команд
    content = re.sub(r'GRANT [^;]*;', '', content)
    
    # Удаление REVOKE команд
    content = re.sub(r'REVOKE [^;]*;', '', content)
    
    # Удаление комментариев к объектам
    content = re.sub(r'COMMENT ON [^;]*;', '', content)
    
    # Подключение к SQLite
    conn = sqlite3.connect(sqlite_db_path)
    cursor = conn.cursor()

    successful_commands = 0
    failed_commands = 0

    # Обработка содержимого дампа
    lines = content.split('\n')
    i = 0
    while i < len(lines):
        line = lines[i].strip()

        if not line or line.startswith('--') or line.startswith('SET ') or 'OWNER TO postgres' in line or 'REVOKE ' in line or 'GRANT ' in line:
            i += 1
            continue

        # Обработка COPY команд (данные)
        if line.startswith('COPY'):
            # Извлечение информации о COPY
            copy_match = re.match(r'COPY ([^ ]+) \(([^)]+)\) FROM stdin', line)
            if copy_match:
                table_name = copy_match.group(1).replace('public.', '')
                columns_str = copy_match.group(2)

                # Пропускаем строку COPY и читаем данные до "\\."
                i += 1
                data_lines = []
                while i < len(lines) and lines[i].strip() != '\\.':
                    data_lines.append(lines[i])
                    i += 1

                # Подготовка SQL для вставки
                columns = [col.strip() for col in columns_str.split(',')]
                placeholders = ', '.join(['?' for _ in columns])
                insert_sql = f"INSERT INTO {table_name} ({columns_str}) VALUES ({placeholders})"

                for data_line in data_lines:
                    if data_line.strip() and data_line.strip() != '\\N':
                        # Разбор строки данных
                        values = []
                        current_val = ""
                        in_quotes = False
                        j = 0
                        while j < len(data_line):
                            char = data_line[j]
                            if char == '\\' and j + 1 < len(data_line) and data_line[j + 1] == '\\':
                                current_val += '\\'
                                j += 2
                                continue
                            elif char == '\t' and not in_quotes:
                                values.append(current_val if current_val != '\\N' else None)
                                current_val = ""
                            elif char == '\\':
                                if j + 1 < len(data_line):
                                    next_char = data_line[j + 1]
                                    if next_char == 't':
                                        current_val += '\t'
                                        j += 2
                                        continue
                                    elif next_char == 'n':
                                        current_val += '\n'
                                        j += 2
                                        continue
                                    elif next_char == 'r':
                                        current_val += '\r'
                                        j += 2
                                        continue
                            else:
                                current_val += char
                            j += 1

                        values.append(current_val if current_val != '\\N' else None)

                        # Выполнение INSERT
                        try:
                            cursor.execute(insert_sql, values)
                            successful_commands += 1
                        except Exception as e:
                            print(f"Ошибка при вставке данных: {str(e)}")
                            failed_commands += 1

                i += 1  # пропускаем "\\."
                continue

        # Обработка CREATE TABLE и других команд
        if 'CREATE TABLE' in line.upper():
            # Читаем до тех пор, пока не найдем закрывающую скобку
            full_cmd = ""
            while i < len(lines):
                current_line = lines[i]
                full_cmd += current_line + "\n"
                if ');' in current_line:
                    break
                i += 1

            # Убираем кавычки и PostgreSQL-специфичные элементы
            full_cmd = re.sub(r'"([^"]*)"', r'\1', full_cmd)
            full_cmd = re.sub(r',\s*,', ',', full_cmd)  # исправление двойных запятых
            full_cmd = full_cmd.replace('public.', '')  # убираем префикс public

            # Удаляем ограничения CHECK
            full_cmd = re.sub(r',\s*CONSTRAINT [^,)]* CHECK \([^)]+\)', '', full_cmd)

            try:
                cursor.execute(full_cmd)
                successful_commands += 1
            except Exception as e:
                print(f"Ошибка при создании таблицы: {str(e)}")
                failed_commands += 1
        elif ('INSERT INTO' in line.upper() or 'DELETE FROM' in line.upper()) and not line.startswith('\\.'):
            # Убираем кавычки и выполняем команду
            clean_cmd = re.sub(r'"([^"]*)"', r'\1', line)
            clean_cmd = clean_cmd.replace('public.', '')  # убираем префикс public

            try:
                cursor.execute(clean_cmd)
                successful_commands += 1
            except Exception as e:
                print(f"Ошибка при выполнении команды: {clean_cmd[:100]}... - {str(e)}")
                failed_commands += 1

        i += 1
    
    # Сохранение изменений
    conn.commit()
    conn.close()
    
    print(f"Конвертация завершена. Успешно: {successful_commands}, Ошибок: {failed_commands}")
    print(f"SQLite база данных сохранена в: {sqlite_db_path}")

if __name__ == "__main__":
    postgres_dump_path = r"C:\Users\Fablab\Downloads\iamthaichef.sql"
    sqlite_db_path = r"C:\Users\Fablab\iamthaichef\db.sqlite3"
    
    # Создаем резервную копию существующей базы данных
    backup_path = r"C:\Users\Fablab\iamthaichef\db.sqlite3.backup"
    if os.path.exists(sqlite_db_path):
        import shutil
        shutil.copy2(sqlite_db_path, backup_path)
        print(f"Создана резервная копия старой базы данных: {backup_path}")
    
    convert_postgres_to_sqlite(postgres_dump_path, sqlite_db_path)