"""
Скрипт для корректной конвертации PostgreSQL дампа в SQLite
"""
import re
import sqlite3
import os
from pathlib import Path

def convert_postgres_to_sqlite_correct(postgres_dump_path, sqlite_db_path):
    """
    Корректно конвертирует дамп PostgreSQL в SQLite базу данных
    """
    print(f"Конвертация дампа {postgres_dump_path} в SQLite базу {sqlite_db_path}")
    
    # Чтение дампа PostgreSQL
    with open(postgres_dump_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Подготовка очищенного SQL для создания структуры
    cleaned_content = content
    
    # Удаление команд SET
    cleaned_content = re.sub(r'SET [^;]*;', '', cleaned_content)
    
    # Удаление команд SELECT pg_catalog.set_config
    cleaned_content = re.sub(r"SELECT pg_catalog\.set_config\([^)]*\);", '', cleaned_content)
    
    # Удаление владельцев таблиц
    cleaned_content = re.sub(r'ALTER TABLE [^;]*OWNER TO postgres;', '', cleaned_content)
    
    # Удаление GRANT команд
    cleaned_content = re.sub(r'GRANT [^;]*;', '', cleaned_content)
    
    # Удаление REVOKE команд
    cleaned_content = re.sub(r'REVOKE [^;]*;', '', cleaned_content)
    
    # Удаление комментариев к объектам
    cleaned_content = re.sub(r'COMMENT ON [^;]*;', '', cleaned_content)
    
    # Замена типов данных
    cleaned_content = cleaned_content.replace('timestamp with time zone', 'TEXT')
    cleaned_content = cleaned_content.replace('timestamp without time zone', 'TEXT')
    cleaned_content = cleaned_content.replace('date', 'TEXT')
    cleaned_content = cleaned_content.replace('boolean', 'INTEGER')
    cleaned_content = cleaned_content.replace('bigint', 'INTEGER')
    cleaned_content = cleaned_content.replace('integer', 'INTEGER')
    cleaned_content = cleaned_content.replace('character varying', 'TEXT')
    cleaned_content = cleaned_content.replace('double precision', 'REAL')
    cleaned_content = cleaned_content.replace('numeric', 'REAL')
    cleaned_content = cleaned_content.replace('bytea', 'BLOB')
    
    # Удаление OID и других PostgreSQL-специфичных элементов
    cleaned_content = re.sub(r'WITH \(oids = [^\)]*\)', '', cleaned_content)
    
    # Удаление ограничений CHECK
    cleaned_content = re.sub(r',\s*CONSTRAINT [^,)]* CHECK \([^)]+\)', '', cleaned_content)
    cleaned_content = re.sub(r',\s*,', ',', cleaned_content)  # исправление двойных запятых
    
    # Удаление последовательностей (GENERATED BY DEFAULT AS IDENTITY)
    cleaned_content = re.sub(r'ADD GENERATED BY DEFAULT AS IDENTITY \([^)]+\)', '', cleaned_content)
    
    # Замена AUTO_INCREMENT для первичных ключей
    cleaned_content = re.sub(r'id integer NOT NULL,\s*\n\s*CONSTRAINT', 'id INTEGER PRIMARY KEY AUTOINCREMENT,\n    CONSTRAINT', cleaned_content)
    cleaned_content = re.sub(r'id bigint NOT NULL,\s*\n\s*CONSTRAINT', 'id INTEGER PRIMARY KEY AUTOINCREMENT,\n    CONSTRAINT', cleaned_content)
    
    # Удаление кавычек вокруг имен
    cleaned_content = re.sub(r'"([^"]*)"', r'\1', cleaned_content)
    
    # Разделение на команды
    commands = cleaned_content.split(';')
    
    # Подключение к SQLite
    # Удаляем старую базу данных, если она существует
    if os.path.exists(sqlite_db_path):
        os.remove(sqlite_db_path)
    
    conn = sqlite3.connect(sqlite_db_path)
    cursor = conn.cursor()
    
    # Создание структуры таблиц
    for cmd in commands:
        cmd = cmd.strip()
        if not cmd or cmd.startswith('--') or cmd.startswith('SET ') or 'OWNER TO postgres' in cmd or 'REVOKE ' in cmd or 'GRANT ' in cmd or 'COMMENT ON' in cmd:
            continue
        
        if 'CREATE TABLE' in cmd.upper():
            # Убираем префикс public
            cmd = cmd.replace('public.', '')
            # Убираем ограничения CHECK, если они остались
            cmd = re.sub(r',\s*CONSTRAINT [^,)]* CHECK \([^)]+\)', '', cmd)
            try:
                cursor.execute(cmd)
                print(f"Таблица создана: {re.search(r'CREATE TABLE (\w+)', cmd).group(1)}")
            except Exception as e:
                print(f"Ошибка при создании таблицы: {str(e)}")
    
    # Теперь обрабатываем COPY команды для вставки данных
    lines = content.split('\n')
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        
        if line.startswith('COPY'):
            # Извлечение информации о COPY
            copy_match = re.match(r'COPY ([^ ]+) \(([^)]+)\) FROM stdin', line)
            if copy_match:
                table_name = copy_match.group(1).replace('public.', '')
                columns_str = copy_match.group(2)
                
                # Пропускаем строку COPY и читаем данные до "\\."
                i += 1
                data_lines = []
                while i < len(lines) and lines[i].strip() != '\\.':
                    data_lines.append(lines[i])
                    i += 1
                
                # Подготовка SQL для вставки
                columns = [col.strip() for col in columns_str.split(',')]
                placeholders = ', '.join(['?' for _ in columns])
                insert_sql = f"INSERT OR IGNORE INTO {table_name} ({columns_str}) VALUES ({placeholders})"
                
                for data_line in data_lines:
                    if data_line.strip() and data_line.strip() != '\\N':
                        # Разбор строки данных
                        values = []
                        current_val = ""
                        in_quotes = False
                        j = 0
                        while j < len(data_line):
                            char = data_line[j]
                            if char == '\\' and j + 1 < len(data_line) and data_line[j + 1] == '\\':
                                current_val += '\\'
                                j += 2
                                continue
                            elif char == '\t' and not in_quotes:
                                values.append(current_val if current_val != '\\N' else None)
                                current_val = ""
                            elif char == '\\':
                                if j + 1 < len(data_line):
                                    next_char = data_line[j + 1]
                                    if next_char == 't':
                                        current_val += '\t'
                                        j += 2
                                        continue
                                    elif next_char == 'n':
                                        current_val += '\n'
                                        j += 2
                                        continue
                                    elif next_char == 'r':
                                        current_val += '\r'
                                        j += 2
                                        continue
                            else:
                                current_val += char
                            j += 1
                        
                        values.append(current_val if current_val != '\\N' else None)
                        
                        # Выполнение INSERT
                        try:
                            cursor.execute(insert_sql, values)
                        except Exception as e:
                            print(f"Ошибка при вставке данных в {table_name}: {str(e)}")
                            print(f"Значения: {values}")
        
        i += 1
    
    # Сохранение изменений
    conn.commit()
    conn.close()
    
    print(f"Конвертация завершена успешно!")
    print(f"SQLite база данных сохранена в: {sqlite_db_path}")

if __name__ == "__main__":
    postgres_dump_path = r"C:\Users\Fablab\Downloads\iamthaichef.sql"
    sqlite_db_path = r"C:\Users\Fablab\iamthaichef\db.sqlite3"
    
    convert_postgres_to_sqlite_correct(postgres_dump_path, sqlite_db_path)